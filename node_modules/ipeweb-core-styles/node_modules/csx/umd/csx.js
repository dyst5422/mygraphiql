var csx =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(11));
__export(__webpack_require__(12));
__export(__webpack_require__(13));


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
var units_1 = __webpack_require__(2);
var delimited = function (delimiter) {
    return function () {
        return utils_1.filter(arguments, function (s) { return s || s === 0; })
            .map(function (s) { return typeof s === 'number' ? units_1.px(s) : s.toString(); })
            .join(delimiter);
    };
};
exports.params = delimited(' ');
exports.list = delimited(',');


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
/**
 * Returns the number with a suffix of %
 */
exports.percent = utils_1.formatUnit('%');
/**
 * Returns the number with a suffix of deg
 */
exports.deg = utils_1.formatUnit('deg');
/**
 * Returns the number with a suffix of em
 */
exports.em = utils_1.formatUnit('em');
/**
 * Returns the number with a suffix of px
 */
exports.px = utils_1.formatUnit('px');
/**
 * Returns the number with a suffix of rad
 */
exports.rad = utils_1.formatUnit('rad');
/**
 * Returns the number with a suffix of rem
 */
exports.rem = utils_1.formatUnit('rem');
/**
 * Returns the number with a suffix of vh
 */
exports.viewHeight = utils_1.formatUnit('vh');
/**
 * Returns the number with a suffix of vw
 */
exports.viewWidth = utils_1.formatUnit('vw');
/**
 * Returns the number with a suffix of turn
 */
exports.turn = utils_1.formatUnit('turn');


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(5));
__export(__webpack_require__(6));
__export(__webpack_require__(7));
__export(__webpack_require__(8));
__export(__webpack_require__(1));
__export(__webpack_require__(9));
__export(__webpack_require__(10));
__export(__webpack_require__(2));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @module Provides useful CSS primitives
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
// export all helper functions
__export(__webpack_require__(3));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
function background() {
    return utils_1.map(arguments, function (background) {
        var s = '';
        if (background.image) {
            s += " " + background.image;
        }
        if (background.position) {
            s += " " + background.position;
        }
        if (background.size || background.size === 0) {
            s += " " + background.size;
        }
        if (background.repeat) {
            s += " " + background.repeat;
        }
        if (background.origin) {
            s += " " + background.origin;
        }
        if (background.clip) {
            s += " " + background.clip;
        }
        if (background.attachment) {
            s += " " + background.attachment;
        }
        if (background.color) {
            s += " " + background.color;
        }
        return s.trim();
    })
        .filter(function (s) { return s !== ''; })
        .join(',');
}
exports.background = background;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
var lists_1 = __webpack_require__(1);
/**
 * Returns the value with '' around it.  Any 's will be escaped \' in the output
 */
function border(p) {
    return lists_1.params(p.color, p.style, utils_1.ensureLength(p.width));
}
exports.border = border;
exports.borderColor = lists_1.params;
exports.borderStyle = lists_1.params;
exports.borderWidth = lists_1.params;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
var isTypeArraySupported = typeof Float32Array !== 'undefined';
var RGB = 0, HSL = 1, R = 0, G = 1, B = 2, H = 0, S = 1, L = 2, A = 3;
/**
 * Map of Color converters.  By subtracting the from-format from the to-format, we can
 * quickly map to the right converter. 1-2 and 2-1 yield different results, so this
 * allows us to choose the right converter observing the direction correcly
 */
var converters = (_a = {},
    _a[RGB - HSL] = RGBtoHSL,
    _a[HSL - RGB] = HSLtoRGB,
    _a);
/**
 * Describe the ceiling for each color channel for each format
 */
var maxChannelValues = (_b = {},
    _b[RGB] = colorArray(255, 255, 255, 1),
    _b[HSL] = colorArray(360, 1, 1, 1),
    _b);
/**
 * Creates a color from a hex color code or named color.
 * e.g. color('red') or color('#FF0000') or color('#F00'))
 */
function color(value) {
    return parseNamedColor(value) || parseHexCode(value) || parseColorFunction(value) || parseNamedColor('red');
}
exports.color = color;
/**
 * Creates a color from hue, saturation, and lightness.  Alpha is automatically set to 100%
 */
function hsl(hue, saturation, lightness) {
    return new ColorHelper(HSL, modDegrees(hue), utils_1.ensurePercent(saturation), utils_1.ensurePercent(lightness), 1, false);
}
exports.hsl = hsl;
/**
 * Creates a color from hue, saturation, lightness, and alpha
 */
function hsla(hue, saturation, lightness, opacity) {
    return new ColorHelper(HSL, modDegrees(hue), utils_1.ensurePercent(saturation), utils_1.ensurePercent(lightness), utils_1.ensurePercent(opacity), true);
}
exports.hsla = hsla;
/**
 * Creates a color form the red, blue, and green color space.  Alpha is automatically set to 100%
 */
function rgb(red, blue, green) {
    return new ColorHelper(RGB, red, blue, green, 1, false);
}
exports.rgb = rgb;
/**
 * Creates a color form the red, blue, green, and alpha in the color space
 */
function rgba(red, blue, green, alpha) {
    return new ColorHelper(RGB, red, blue, green, utils_1.ensurePercent(alpha), true);
}
exports.rgba = rgba;
/**
 * A CSS Color.  Includes utilities for converting between color types
 */
var ColorHelper = (function () {
    function ColorHelper(format, c0, c1, c2, c3, hasAlpha) {
        this._format = format;
        this._hasAlpha = hasAlpha;
        this._values = colorArray(clampColor(format, 0, c0), clampColor(format, 1, c1), clampColor(format, 2, c2), clampColor(format, 3, c3));
    }
    ColorHelper.convertHelper = function (toFormat, helper) {
        var fromFormat = helper._format;
        var v = helper._values;
        var a = helper._hasAlpha;
        return fromFormat === toFormat
            ? helper
            : converters[fromFormat - toFormat](v[R], v[G], v[B], v[A], a);
    };
    /**
     * Converts the stored color into string form (which is used by Free Style)
     */
    ColorHelper.prototype.toString = function () {
        var format = this._format;
        var v = this._values;
        var hasAlpha = this._hasAlpha;
        var fnName;
        var params;
        // find function name and resolve first three channels
        if (format === RGB) {
            fnName = hasAlpha ? 'rgba' : 'rgb';
            params = [Math.round(v[R]), Math.round(v[G]), Math.round(v[B])];
        }
        else if (format === HSL) {
            fnName = hasAlpha ? 'hsla' : 'hsl';
            params = [Math.round(v[H]), utils_1.formatPercent(utils_1.roundFloat(v[S], 100)), utils_1.formatPercent(utils_1.roundFloat(v[L], 100))];
        }
        else {
            throw new Error('Invalid color format');
        }
        // add alpha channel if needed
        if (hasAlpha) {
            params.push(utils_1.formatFloat(utils_1.roundFloat(v[A], 100000)));
        }
        // return as a string
        return utils_1.cssFunction(fnName, params);
    };
    /**
     * Converts to hex rgb(255, 255, 255) to #FFFFFF
     */
    ColorHelper.prototype.toHexString = function () {
        var v = ColorHelper.convertHelper(RGB, this)._values;
        return '#' + (toHex(v[R]) + toHex(v[G]) + toHex(v[B])).toUpperCase();
    };
    /**
     * Converts to the Hue, Saturation, Lightness color space
     */
    ColorHelper.prototype.toHSL = function () {
        var v = this._values;
        return convert(this._format, HSL, v[H], v[S], v[L], 1, false);
    };
    /**
     * Converts to the Hue, Saturation, Lightness color space and adds an alpha channel
     */
    ColorHelper.prototype.toHSLA = function () {
        var v = this._values;
        return convert(this._format, HSL, v[H], v[S], v[L], v[A], true);
    };
    /**
     * Converts to the Red, Green, Blue color space
     */
    ColorHelper.prototype.toRGB = function () {
        var v = this._values;
        return convert(this._format, RGB, v[R], v[G], v[B], 1, false);
    };
    /**
     * Converts to the Red, Green, Blue color space and adds an alpha channel
     */
    ColorHelper.prototype.toRGBA = function () {
        var v = this._values;
        return convert(this._format, RGB, v[R], v[G], v[B], v[A], true);
    };
    ColorHelper.prototype.red = function () {
        return (this._format === RGB ? this : this.toRGB())._values[0];
    };
    ColorHelper.prototype.green = function () {
        return (this._format === RGB ? this : this.toRGB())._values[1];
    };
    ColorHelper.prototype.blue = function () {
        return (this._format === RGB ? this : this.toRGB())._values[2];
    };
    ColorHelper.prototype.hue = function () {
        return (this._format === HSL ? this : this.toHSL())._values[0];
    };
    ColorHelper.prototype.saturation = function () {
        return (this._format === HSL ? this : this.toHSL())._values[1];
    };
    ColorHelper.prototype.lightness = function () {
        return (this._format === HSL ? this : this.toHSL())._values[2];
    };
    ColorHelper.prototype.alpha = function () {
        return this._values[A];
    };
    ColorHelper.prototype.opacity = function () {
        return this.alpha();
    };
    ColorHelper.prototype.invert = function () {
        var v = ColorHelper.convertHelper(RGB, this)._values;
        return ColorHelper.convertHelper(this._format, new ColorHelper(RGB, 255 - v[R], 255 - v[G], 255 - v[B], this._values[A], this._hasAlpha));
    };
    ColorHelper.prototype.lighten = function (percent, relative) {
        var v = ColorHelper.convertHelper(HSL, this)._values;
        var max = maxChannelValues[HSL][L];
        var l = v[L] + ((relative ? (max - v[L]) : max) * utils_1.ensurePercent(percent));
        return ColorHelper.convertHelper(this._format, new ColorHelper(HSL, v[H], v[S], l, this._values[A], this._hasAlpha));
    };
    ColorHelper.prototype.darken = function (percent, relative) {
        var v = ColorHelper.convertHelper(HSL, this)._values;
        var l = v[L] - ((relative ? v[L] : maxChannelValues[HSL][L]) * utils_1.ensurePercent(percent));
        return ColorHelper.convertHelper(this._format, new ColorHelper(HSL, v[H], v[S], l, this._values[A], this._hasAlpha));
    };
    ColorHelper.prototype.saturate = function (percent, relative) {
        var v = ColorHelper.convertHelper(HSL, this)._values;
        var max = maxChannelValues[HSL][S];
        var s = v[S] + ((relative ? (max - v[S]) : max) * utils_1.ensurePercent(percent));
        return ColorHelper.convertHelper(this._format, new ColorHelper(HSL, v[H], s, v[L], this._values[A], this._hasAlpha));
    };
    ColorHelper.prototype.desaturate = function (percent, relative) {
        var v = ColorHelper.convertHelper(HSL, this)._values;
        var max = maxChannelValues[HSL][S];
        var s = v[S] - ((relative ? v[S] : max) * utils_1.ensurePercent(percent));
        return ColorHelper.convertHelper(this._format, new ColorHelper(HSL, v[H], s, v[L], this._values[A], this._hasAlpha));
    };
    ColorHelper.prototype.grayscale = function () {
        return this.desaturate(1);
    };
    ColorHelper.prototype.fade = function (percent) {
        var v = this._values;
        var a = clampColor(RGB, A, utils_1.ensurePercent(percent));
        return ColorHelper.convertHelper(this._format, new ColorHelper(this._format, v[R], v[G], v[B], a, true));
    };
    ColorHelper.prototype.fadeOut = function (percent, relative) {
        var v = this._values;
        var max = 1;
        var a = clampColor(RGB, A, v[A] - ((relative ? v[A] : max) * utils_1.ensurePercent(percent)));
        return ColorHelper.convertHelper(this._format, new ColorHelper(this._format, v[R], v[G], v[B], a, true));
    };
    ColorHelper.prototype.fadeIn = function (percent, relative) {
        var v = this._values;
        var max = 1;
        var a = clampColor(RGB, A, v[A] + ((relative ? v[A] : max) * utils_1.ensurePercent(percent)));
        return ColorHelper.convertHelper(this._format, new ColorHelper(this._format, v[R], v[G], v[B], a, true));
    };
    ColorHelper.prototype.mix = function (mixin, weight) {
        var color1 = this;
        var color2 = ensureColor(mixin);
        var c1 = ColorHelper.convertHelper(RGB, color1)._values;
        var c2 = ColorHelper.convertHelper(RGB, color2)._values;
        var p = weight === undefined ? .5 : weight;
        var w = 2 * p - 1;
        var a = Math.abs(c1[A] - c2[A]);
        var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        var helper = new ColorHelper(RGB, Math.round((c1[R] * w1 + c2[R] * w2)), Math.round((c1[G] * w1 + c2[G] * w2)), Math.round((c1[B] * w1 + c2[B] * w2)), c1[A] * p + c2[A] * (1 - p), color1._hasAlpha || color2._hasAlpha);
        return ColorHelper.convertHelper(this._format, helper);
    };
    ColorHelper.prototype.tint = function (weight) {
        return exports.white.mix(this, weight);
    };
    ColorHelper.prototype.shade = function (weight) {
        return exports.black.mix(this, weight);
    };
    ColorHelper.prototype.spin = function (degrees) {
        var v = ColorHelper.convertHelper(HSL, this)._values;
        return ColorHelper.convertHelper(this._format, new ColorHelper(HSL, modDegrees(v[H] + degrees), v[S], v[L], this._values[A], this._hasAlpha));
    };
    return ColorHelper;
}());
exports.ColorHelper = ColorHelper;
/**
 * Named colors in the CSS spec. They must be loaded after exported functions and constructor
 *
 */
var namedColors = {
    aliceblue: rgb(240, 248, 245),
    antiquewhite: rgb(250, 235, 215),
    aqua: rgb(0, 255, 255),
    aquamarine: rgb(127, 255, 212),
    azure: rgb(240, 255, 255),
    beige: rgb(245, 245, 220),
    bisque: rgb(255, 228, 196),
    black: rgb(0, 0, 0),
    blanchedalmond: rgb(255, 235, 205),
    blue: rgb(0, 0, 255),
    blueviolet: rgb(138, 43, 226),
    brown: rgb(165, 42, 42),
    burlywood: rgb(222, 184, 35),
    cadetblue: rgb(95, 158, 160),
    chartreuse: rgb(127, 255, 0),
    chocolate: rgb(210, 105, 30),
    coral: rgb(255, 127, 80),
    cornflowerblue: rgb(100, 149, 237),
    cornsilk: rgb(255, 248, 220),
    crimson: rgb(220, 20, 60),
    cyan: rgb(0, 255, 255),
    darkblue: rgb(0, 0, 139),
    darkcyan: rgb(0, 139, 139),
    darkgoldenrod: rgb(184, 134, 11),
    darkgray: rgb(169, 169, 169),
    darkgreen: rgb(0, 100, 0),
    darkgrey: rgb(169, 169, 169),
    darkkhaki: rgb(189, 183, 107),
    darkmagenta: rgb(139, 0, 139),
    darkolivegreen: rgb(85, 107, 47),
    darkorange: rgb(255, 140, 0),
    darkorchid: rgb(153, 50, 204),
    darkred: rgb(139, 0, 0),
    darksalmon: rgb(233, 150, 122),
    darkseagreen: rgb(143, 188, 143),
    darkslateblue: rgb(72, 61, 139),
    darkslategray: rgb(47, 79, 79),
    darkslategrey: rgb(47, 79, 79),
    darkturquoise: rgb(0, 206, 209),
    darkviolet: rgb(148, 0, 211),
    deeppink: rgb(255, 20, 147),
    deepskyblue: rgb(0, 191, 255),
    dimgray: rgb(105, 105, 105),
    dimgrey: rgb(105, 105, 105),
    dodgerblue: rgb(30, 144, 255),
    firebrick: rgb(178, 34, 34),
    floralwhite: rgb(255, 250, 240),
    forestgreen: rgb(34, 139, 34),
    fuchsia: rgb(255, 0, 255),
    gainsboro: rgb(220, 220, 220),
    ghostwhite: rgb(248, 248, 255),
    gold: rgb(255, 215, 0),
    goldenrod: rgb(218, 165, 32),
    gray: rgb(128, 128, 128),
    green: rgb(0, 128, 0),
    greenyellow: rgb(173, 255, 47),
    grey: rgb(128, 128, 128),
    honeydew: rgb(240, 255, 240),
    hotpink: rgb(255, 105, 180),
    indianred: rgb(205, 92, 92),
    indigo: rgb(75, 0, 130),
    ivory: rgb(255, 255, 240),
    khaki: rgb(240, 230, 140),
    lavender: rgb(230, 230, 250),
    lavenderblush: rgb(255, 240, 245),
    lawngreen: rgb(124, 252, 0),
    lemonchiffon: rgb(255, 250, 205),
    lightblue: rgb(173, 216, 230),
    lightcoral: rgb(240, 128, 128),
    lightcyan: rgb(224, 255, 255),
    lightgoldenrodyellow: rgb(250, 250, 210),
    lightgray: rgb(211, 211, 211),
    lightgreen: rgb(144, 238, 144),
    lightgrey: rgb(211, 211, 211),
    lightpink: rgb(255, 182, 193),
    lightsalmon: rgb(255, 160, 122),
    lightseagreen: rgb(32, 178, 170),
    lightskyblue: rgb(135, 206, 250),
    lightslategray: rgb(119, 136, 153),
    lightslategrey: rgb(119, 136, 153),
    lightsteelblue: rgb(176, 196, 222),
    lightyellow: rgb(255, 255, 224),
    lime: rgb(0, 255, 0),
    limegreen: rgb(50, 205, 50),
    linen: rgb(250, 240, 230),
    maroon: rgb(128, 0, 0),
    mediumaquamarine: rgb(102, 205, 170),
    mediumblue: rgb(0, 0, 205),
    mediumorchid: rgb(186, 85, 211),
    mediumpurple: rgb(147, 112, 219),
    mediumseagreen: rgb(60, 179, 113),
    mediumslateblue: rgb(123, 104, 238),
    mediumspringgreen: rgb(0, 250, 154),
    mediumturquoise: rgb(72, 209, 204),
    mediumvioletred: rgb(199, 21, 133),
    midnightblue: rgb(25, 25, 112),
    mintcream: rgb(245, 255, 250),
    mistyrose: rgb(255, 228, 225),
    moccasin: rgb(255, 228, 181),
    navajowhite: rgb(255, 222, 173),
    navy: rgb(0, 0, 128),
    oldlace: rgb(253, 245, 230),
    olive: rgb(128, 128, 0),
    olivedrab: rgb(107, 142, 35),
    orange: rgb(255, 165, 0),
    purple: rgb(128, 0, 128),
    rebeccapurple: rgb(102, 51, 153),
    red: rgb(255, 0, 0),
    silver: rgb(192, 192, 192),
    teal: rgb(0, 128, 128),
    transparent: rgba(0, 0, 0, 0),
    white: rgb(255, 255, 255),
    yellow: rgb(255, 255, 0),
};
exports.aliceblue = namedColors.aliceblue, exports.antiquewhite = namedColors.antiquewhite, exports.aqua = namedColors.aqua, exports.aquamarine = namedColors.aquamarine, exports.azure = namedColors.azure, exports.beige = namedColors.beige, exports.bisque = namedColors.bisque, exports.black = namedColors.black, exports.blanchedalmond = namedColors.blanchedalmond, exports.blue = namedColors.blue, exports.blueviolet = namedColors.blueviolet, exports.brown = namedColors.brown, exports.burlywood = namedColors.burlywood, exports.cadetblue = namedColors.cadetblue, exports.chartreuse = namedColors.chartreuse, exports.chocolate = namedColors.chocolate, exports.coral = namedColors.coral, exports.cornflowerblue = namedColors.cornflowerblue, exports.cornsilk = namedColors.cornsilk, exports.crimson = namedColors.crimson, exports.cyan = namedColors.cyan, exports.darkblue = namedColors.darkblue, exports.darkcyan = namedColors.darkcyan, exports.darkgoldenrod = namedColors.darkgoldenrod, exports.darkgray = namedColors.darkgray, exports.darkgreen = namedColors.darkgreen, exports.darkgrey = namedColors.darkgrey, exports.darkkhaki = namedColors.darkkhaki, exports.darkmagenta = namedColors.darkmagenta, exports.darkolivegreen = namedColors.darkolivegreen, exports.darkorange = namedColors.darkorange, exports.darkorchid = namedColors.darkorchid, exports.darkred = namedColors.darkred, exports.darksalmon = namedColors.darksalmon, exports.darkseagreen = namedColors.darkseagreen, exports.darkslateblue = namedColors.darkslateblue, exports.darkslategray = namedColors.darkslategray, exports.darkslategrey = namedColors.darkslategrey, exports.darkturquoise = namedColors.darkturquoise, exports.darkviolet = namedColors.darkviolet, exports.deeppink = namedColors.deeppink, exports.deepskyblue = namedColors.deepskyblue, exports.dimgray = namedColors.dimgray, exports.dimgrey = namedColors.dimgrey, exports.dodgerblue = namedColors.dodgerblue, exports.firebrick = namedColors.firebrick, exports.floralwhite = namedColors.floralwhite, exports.forestgreen = namedColors.forestgreen, exports.fuchsia = namedColors.fuchsia, exports.gainsboro = namedColors.gainsboro, exports.ghostwhite = namedColors.ghostwhite, exports.gold = namedColors.gold, exports.goldenrod = namedColors.goldenrod, exports.gray = namedColors.gray, exports.green = namedColors.green, exports.greenyellow = namedColors.greenyellow, exports.grey = namedColors.grey, exports.honeydew = namedColors.honeydew, exports.hotpink = namedColors.hotpink, exports.indianred = namedColors.indianred, exports.indigo = namedColors.indigo, exports.ivory = namedColors.ivory, exports.khaki = namedColors.khaki, exports.lavender = namedColors.lavender, exports.lavenderblush = namedColors.lavenderblush, exports.lawngreen = namedColors.lawngreen, exports.lemonchiffon = namedColors.lemonchiffon, exports.lightblue = namedColors.lightblue, exports.lightcoral = namedColors.lightcoral, exports.lightcyan = namedColors.lightcyan, exports.lightgoldenrodyellow = namedColors.lightgoldenrodyellow, exports.lightgray = namedColors.lightgray, exports.lightgreen = namedColors.lightgreen, exports.lightgrey = namedColors.lightgrey, exports.lightpink = namedColors.lightpink, exports.lightsalmon = namedColors.lightsalmon, exports.lightseagreen = namedColors.lightseagreen, exports.lightskyblue = namedColors.lightskyblue, exports.lightslategray = namedColors.lightslategray, exports.lightslategrey = namedColors.lightslategrey, exports.lightsteelblue = namedColors.lightsteelblue, exports.lightyellow = namedColors.lightyellow, exports.lime = namedColors.lime, exports.limegreen = namedColors.limegreen, exports.linen = namedColors.linen, exports.maroon = namedColors.maroon, exports.mediumaquamarine = namedColors.mediumaquamarine, exports.mediumblue = namedColors.mediumblue, exports.mediumorchid = namedColors.mediumorchid, exports.mediumpurple = namedColors.mediumpurple, exports.mediumseagreen = namedColors.mediumseagreen, exports.mediumslateblue = namedColors.mediumslateblue, exports.mediumspringgreen = namedColors.mediumspringgreen, exports.mediumturquoise = namedColors.mediumturquoise, exports.mediumvioletred = namedColors.mediumvioletred, exports.midnightblue = namedColors.midnightblue, exports.mintcream = namedColors.mintcream, exports.mistyrose = namedColors.mistyrose, exports.moccasin = namedColors.moccasin, exports.navajowhite = namedColors.navajowhite, exports.navy = namedColors.navy, exports.oldlace = namedColors.oldlace, exports.olive = namedColors.olive, exports.olivedrab = namedColors.olivedrab, exports.orange = namedColors.orange, exports.purple = namedColors.purple, exports.rebeccapurple = namedColors.rebeccapurple, exports.red = namedColors.red, exports.silver = namedColors.silver, exports.teal = namedColors.teal, exports.transparent = namedColors.transparent, exports.white = namedColors.white, exports.yellow = namedColors.yellow;
function toHex(n) {
    var i = Math.round(n);
    return (i < 16 ? '0' : '') + i.toString(16);
}
function modDegrees(n) {
    // note: maybe there is a way to simplify this
    return ((n < 0 ? 360 : 0) + (n % 360)) % 360;
}
function RGBtoHSL(c0, c1, c2, c3, hasAlpha) {
    var r = c0 / 255;
    var g = c1 / 255;
    var b = c2 / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var l = (min + max) / 2;
    var delta = max - min;
    var h;
    if (max === min) {
        h = 0;
    }
    else if (r === max) {
        h = (g - b) / delta;
    }
    else if (g === max) {
        h = 2 + (b - r) / delta;
    }
    else if (b === max) {
        h = 4 + (r - g) / delta;
    }
    else {
        h = 0;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
        h += 360;
    }
    var s;
    if (max === min) {
        s = 0;
    }
    else if (l <= 0.5) {
        s = delta / (max + min);
    }
    else {
        s = delta / (2 - max - min);
    }
    return new ColorHelper(HSL, h, s, l, c3, hasAlpha);
}
;
function HSLtoRGB(c0, c1, c2, c3, hasAlpha) {
    var h = c0 / 360;
    var s = c1;
    var l = c2;
    if (s === 0) {
        var val = l * 255;
        return new ColorHelper(RGB, val, val, val, c3, hasAlpha);
    }
    var t2 = l < .5 ? l * (1 + s) : l + s - l * s;
    var t1 = 2 * l - t2;
    var r = 0, g = 0, b = 0;
    for (var i = 0; i < 3; i++) {
        var t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
            t3++;
        }
        if (t3 > 1) {
            t3--;
        }
        var val = void 0;
        if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
        }
        else if (2 * t3 < 1) {
            val = t2;
        }
        else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        }
        else {
            val = t1;
        }
        val *= 255;
        // manually set variables instead of using an array
        if (i === 0) {
            r = val;
        }
        else if (i === 1) {
            g = val;
        }
        else {
            b = val;
        }
    }
    return new ColorHelper(RGB, r, g, b, c3, hasAlpha);
}
;
/**
 * Converts from one format to another format
 */
function convert(fromFormat, toFormat, c0, c1, c2, c3, hasAlpha) {
    return fromFormat === toFormat
        ? new ColorHelper(fromFormat, c0, c1, c2, c3, hasAlpha)
        : converters[fromFormat - toFormat](c0, c1, c2, c3, hasAlpha);
}
function colorArray(c0, c1, c2, c3) {
    if (!isTypeArraySupported) {
        return [c0 || 0, c1 || 0, c2 || 0, c3 || 0];
    }
    var a = new Float32Array(4);
    a[0] = c0 || 0;
    a[1] = c1 || 0;
    a[2] = c2 || 0;
    a[3] = c3 || 0;
    return a;
}
function clampColor(format, channel, value) {
    var min = 0;
    var max = maxChannelValues[format][channel];
    return value < min ? min : value > max ? max : value;
}
function ensureColor(c) {
    return c instanceof ColorHelper ? c : color(c);
}
function parseNamedColor(stringValue) {
    return namedColors[stringValue] || undefined;
}
function parseHexCode(stringValue) {
    var match = stringValue.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
    if (!match) {
        return undefined;
    }
    var hex = match[1];
    var hexColor = parseInt(hex.length === 3
        ? hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
        : hex, 16);
    var r = (hexColor >> 16) & 0xFF;
    var b = (hexColor >> 8) & 0xFF;
    var g = hexColor & 0xFF;
    return new ColorHelper(RGB, r, b, g, 1, false);
}
;
function parseColorFunction(colorString) {
    var cssParts = utils_1.parseCSSFunction(colorString);
    if (!cssParts || !(cssParts.length === 4 || cssParts.length === 5)) {
        return undefined;
    }
    var fn = cssParts[0];
    var isRGBA = fn === 'rgba';
    var isHSLA = fn === 'hsla';
    var isRGB = fn === 'rgb';
    var isHSL = fn === 'hsl';
    var hasAlpha = isHSLA || isRGBA;
    var type;
    if (isRGB || isRGBA) {
        type = RGB;
    }
    else if (isHSL || isHSLA) {
        type = HSL;
    }
    else {
        throw new Error('unsupported color string');
    }
    var c0 = parseFloat(cssParts[1]);
    var c1 = isRGB || isRGBA ? parseFloat(cssParts[2]) : utils_1.ensurePercent(cssParts[2]);
    var c2 = isRGB || isRGBA ? parseFloat(cssParts[3]) : utils_1.ensurePercent(cssParts[3]);
    var c3 = hasAlpha ? parseFloat(cssParts[4]) : 1;
    return new ColorHelper(type, c0, c1, c2, c3, hasAlpha);
}
var _a, _b;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
/**
 * Helper for the linear-gradient function in CSS
 * https://drafts.csswg.org/css-images-3/#funcdef-linear-gradient
 */
function linearGradient(position) {
    var colors = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        colors[_i - 1] = arguments[_i];
    }
    return utils_1.cssFunction('linear-gradient', [position].concat(colors.map(flattenColorStops)));
}
exports.linearGradient = linearGradient;
/**
 * Helper for the repeating-linear-gradient function in CSS
 * https://drafts.csswg.org/css-images-3/#funcdef-repeating-linear-gradient
 */
function repeatingLinearGradient(position) {
    var colors = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        colors[_i - 1] = arguments[_i];
    }
    return utils_1.cssFunction('repeating-linear-gradient', [position].concat(colors.map(flattenColorStops)));
}
exports.repeatingLinearGradient = repeatingLinearGradient;
/**
 * Single CSSColorStop => string conversion is like:
 * 'x'=>'x'
 * ['x', '50%'] => 'x 50%'
 **/
function flattenColorStops(c) {
    return Array.isArray(c) ? c.map(function (s) { return s.toString(); }).join(' ') : c.toString();
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns the value with '' around it.  Any 's will be escaped \' in the output
 */
function calc(exp) {
    return "calc(" + exp + ")";
}
exports.calc = calc;
/**
 * Returns the value with '' around it.  Any 's will be escaped \' in the output
 */
function quote(val) {
    var val2 = (val || val === 0 ? val.toString() : '').replace(/\'/g, "\\'");
    return "'" + val2 + "'";
}
exports.quote = quote;
function important(val) {
    if (!val && val !== 0) {
        return '';
    }
    return val.toString() + " !important";
}
exports.important = important;
/**
 * Returns the string in a url()
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/url
 */
function url(val) {
    return "url(" + (val || '') + ")";
}
exports.url = url;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(0);
/**
 * The CSS transform property lets you modify the coordinate space of the CSS visual formatting model. Using it, elements can be translated, rotated, scaled, and skewed.
 * Returns the transforms as a delimited string by space or returns 'none' if no arguments are provided
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform
 */
function transform() {
    var transforms = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transforms[_i] = arguments[_i];
    }
    return transforms.length ? transforms.join(' ') : 'none';
}
exports.transform = transform;
/**
 * The matrix() CSS function specifies a homogeneous 2D transformation matrix comprised of the specified six values. The constant values of such matrices are implied and not passed as parameters; the other parameters are described in the column-major order.
 *
 * matrix(a, b, c, d, tx, ty) is a shorthand for matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix
 */
function matrix(a, b, c, d, tx, ty) {
    return utils_1.cssFunction('matrix', [a, b, c, d, tx, ty]);
}
exports.matrix = matrix;
/**
 * The matrix3d() CSS function describes a 3D transform as a 4x4 homogeneous matrix. The 16 parameters are described in the column-major order.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d
 */
function matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
    return utils_1.cssFunction('matrix3d', [a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4]);
}
exports.matrix3d = matrix3d;
/**
 * The perspective() CSS function defines the distance between the z=0 plane and the user in order to give to the 3D-positioned element some perspective. Each 3D element with z>0 becomes larger; each 3D-element with z<0 becomes smaller. The strength of the effect is determined by the value of this property.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/perspective
 */
function perspective(value) {
    return utils_1.cssFunction('perspective', [value]);
}
exports.perspective = perspective;
/**
 * The rotate() CSS function defines a transformation that moves the element around a fixed point (as specified by the transform-origin property) without deforming it. The amount of movement is defined by the specified angle; if positive, the movement will be clockwise, if negative, it will be counter-clockwise. A rotation by 180Â° is called point reflection.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate
 */
function rotate(z) {
    return utils_1.cssFunction('rotate', [z]);
}
exports.rotate = rotate;
/**
 * The rotate3d()CSS function defines a transformation that moves the element around a fixed axis without deforming it. The amount of movement is defined by the specified angle; if positive, the movement will be clockwise, if negative, it will be counter-clockwise.In opposition to rotations in the plane, the composition of 3D rotations is usually not commutative; it means that the order in which the rotations are applied is crucial.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d
 */
function rotate3d(x, y, z) {
    return utils_1.cssFunction('rotate3d', [x, y, z]);
}
exports.rotate3d = rotate3d;
/**
 * The rotateX()CSS function defines a transformation that moves the element around the abscissa without deforming it. The amount of movement is defined by the specified angle; if positive, the movement will be clockwise, if negative, it will be counter-clockwise. The axis of rotation passes by the origin, defined by transform-origin CSS property.
 *
 * rotateX(a)is a shorthand for rotate3d(1, 0, 0, a).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotateX
 */
function rotateX(x) {
    return utils_1.cssFunction('rotateX', [x]);
}
exports.rotateX = rotateX;
/**
 * The rotateY()CSS function defines a transformation that moves the element around the ordinate without deforming it. The amount of movement is defined by the specified angle; if positive, the movement will be clockwise, if negative, it will be counter-clockwise. The axis of rotation passes by the origin, defined by transform-origin CSS property.
 *
 * rotateY(a)is a shorthand for rotate3d(0, 1, 0, a).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotateY
 */
function rotateY(y) {
    return utils_1.cssFunction('rotateY', [y]);
}
exports.rotateY = rotateY;
/**
 * The rotateZ()CSS function defines a transformation that moves the element around the z-axis without deforming it. The amount of movement is defined by the specified angle; if positive, the movement will be clockwise, if negative, it will be counter-clockwise. The axis of rotation passes by the origin, defined by transform-origin CSS property.
 *
 * rotateZ(a)is a shorthand for rotate3d(0, 0, 1, a).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotateZ
 */
function rotateZ(z) {
    return utils_1.cssFunction('rotateZ', [z]);
}
exports.rotateZ = rotateZ;
/**
 * The scale() CSS function modifies the size of the element. It can either augment or decrease its size and as the amount of scaling is defined by a vector, it can do so more in one direction than in another one. This transformation is characterized by a vector whose coordinates define how much scaling is done in each direction. If both coordinates of the vector are equal, the scaling is uniform, or isotropic, and the shape of the element is preserved. In that case, the scaling function defines a homothetic transformation.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale
 */
function scale(x, y) {
    return utils_1.cssFunction('scale', (y || y === 0) ? [x, y] : [x]);
}
exports.scale = scale;
/**
 * The scale3d() CSS function modifies the size of an element. Because the amount of scaling is defined by a vector, it can resize different dimensions at different scales. This transformation is characterized by a vector whose coordinates define how much scaling is done in each direction. If all three coordinates of the vector are equal, the scaling is uniform, or isotropic, and the shape of the element is preserved. In that case, the scaling function defines a homothetic transformation.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale3d
 */
function scale3d(x, y, z) {
    return utils_1.cssFunction('scale3d', [x, y, z]);
}
exports.scale3d = scale3d;
/**
 * The scaleX() CSS function modifies the abscissa of each element point by a constant factor, except if this scale factor is 1, in which case the function is the identity transform. The scaling is not isotropic and the angles of the element are not conserved. scaleX(-1) defines an axial symmetry with a vertical axis passing by the origin (as specified by the transform-origin property).
 *
 * scaleX(sx) is a shorthand for scale(sx, 1) or for scale3d(sx, 1, 1).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scaleX
 */
function scaleX(x) {
    return utils_1.cssFunction('scaleX', [x]);
}
exports.scaleX = scaleX;
/**
 * The scaleY() CSS function modifies the ordinate of each element point by a constant factor except if this scale factor is 1, in which case the function is the identity transform. The scaling is not isotropic and the angles of the element are not conserved. scaleY(-1) defines an axial symmetry with a horizontal axis passing by the origin (as specified by the transform-origin property).
 *
 * scaleY(sy) is a shorthand for scale(1, sy) or for scale3d(1, sy, 1).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scaleY
 */
function scaleY(y) {
    return utils_1.cssFunction('scaleY', [y]);
}
exports.scaleY = scaleY;
/**
 * The scaleZ() CSS function modifies the z-coordinate of each element point by a constant factor, except if this scale factor is 1, in which case the function is the identity transform. The scaling is not isotropic and the angles of the element are not conserved. scaleZ(-1) defines an axial symmetry along the z-axis passing by the origin (as specified by the transform-origin property).
 *
 * scaleZ(sz) is a shorthand for scale3d(1, 1, sz).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scaleZ
 */
function scaleZ(z) {
    return utils_1.cssFunction('scaleZ', [z]);
}
exports.scaleZ = scaleZ;
/**
 * The skew() CSS function is a shear mapping, or transvection, distorting each point of an element by a certain angle in each direction. It is done by increasing each coordinate by a value proportionate to the specified angle and to the distance to the origin. The more far from the origin, the more away the point is, the greater will be the value added to it.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew
 */
function skew(x, y) {
    return utils_1.cssFunction('skew', (y || y === 0) ? [x, y] : [x]);
}
exports.skew = skew;
/**
 * The skewX() CSS function is a horizontal shear mapping distorting each point of an element by a certain angle in the horizontal direction. It is done by increasing the abscissa coordinate by a value proportionate to the specified angle and to the distance to the origin. The more far from the origin, the more away the point is, the greater will be the value added to it.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewX
 */
function skewX(x) {
    return utils_1.cssFunction('skewX', [x]);
}
exports.skewX = skewX;
/**
 * The skewY() CSS function is a vertical shear mapping distorting each point of an element by a certain angle in the vertical direction. It is done by increasing the ordinate coordinate by a value proportionate to the specified angle and to the distance to the origin. The more far from the origin, the more away the point is, the greater will be the value added to it.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skewY
 */
function skewY(y) {
    return utils_1.cssFunction('skewY', [y]);
}
exports.skewY = skewY;
/**
 * The translate() CSS function moves the position of the element on the plane. This transformation is characterized by a vector whose coordinates define how much it moves in each direction.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate
 */
function translate(x, y) {
    return utils_1.cssFunction('translate', (y || y === 0) ? [x, y] : [x]);
}
exports.translate = translate;
/**
 * The translate3d() CSS function moves the position of the element in the 3D space. This transformation is characterized by a 3-dimension vector whose coordinates define how much it moves in each direction.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate3d
 */
function translate3d(x, y, z) {
    return utils_1.cssFunction('translate3d', [x, y, z]);
}
exports.translate3d = translate3d;
/**
 * The translateX() CSS function moves the element horizontally on the plane. This transformation is characterized by a <length> defining how much it moves horizontally.
 *
 * translateX(tx) is a shortcut for translate(tx, 0).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translateX
 */
function translateX(x) {
    return utils_1.cssFunction('translateX', [x]);
}
exports.translateX = translateX;
/**
 * The translateY() CSS function moves the element vertically on the plane. This transformation is characterized by a <length> defining how much it moves vertically.
 *
 * translateY(ty) is a shortcut for translate(0, ty).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translateY
 */
function translateY(y) {
    return utils_1.cssFunction('translateY', [y]);
}
exports.translateY = translateY;
/**
 * The translateZ() CSS function moves the element along the z-axis of the 3D space. This transformation is characterized by a <length> defining how much it moves.
 *
 * translateZ(tz) is a shorthand for translate3d(0, 0, tz).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translateZ
 */
function translateZ(z) {
    return utils_1.cssFunction('translateZ', [z]);
}
exports.translateZ = translateZ;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.filter = function (args, condition) {
    return Array.prototype.filter.call(args, condition);
};
exports.map = function (args, mapper) {
    return Array.prototype.map.call(args, mapper);
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i;
var floatExpression = /^(\-?\d+\.?\d{0,5})/;
exports.formatUnit = function (unit) { return function (val) { return (val + unit); }; };
function ensurePercent(value) {
    return typeof value === 'number'
        ? value
        : parseFloat(value) * .01;
}
exports.ensurePercent = ensurePercent;
function formatPercent(value) {
    return (formatFloat(value * 100)) + '%';
}
exports.formatPercent = formatPercent;
/**
 * Returns a number formatted to a max number of 5 decimal places
 */
function formatFloat(n) {
    return floatExpression.exec(n.toString())[1];
}
exports.formatFloat = formatFloat;
function ensureLength(value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    // convert to number
    var number = +value;
    // validate conversion worked (NaN will not equal NaN)
    if (number === number) {
        return value + 'px';
    }
    return value;
}
exports.ensureLength = ensureLength;
function parseCSSFunction(stringValue) {
    var matches = functionExpression.exec(stringValue);
    if (!matches || !matches.length) {
        return undefined;
    }
    return [matches[1]].concat(matches[2].split(','));
}
exports.parseCSSFunction = parseCSSFunction;
function cssFunction(functionName, params) {
    var parts = Array.prototype.join.call(params, ',');
    return functionName + "(" + parts + ")";
}
exports.cssFunction = cssFunction;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Rounds a decimal by multiplying it by a factor, rounding it, and then dividing it by that same factor
 * @param n number to round
 * @param factor to use 100 = scale of 2, 100000 = scale of 5
 */
function roundFloat(n, factor) {
    return Math.round(n * factor) / factor;
}
exports.roundFloat = roundFloat;


/***/ })
/******/ ]);